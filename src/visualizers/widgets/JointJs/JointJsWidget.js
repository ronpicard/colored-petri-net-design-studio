/*globals define, WebGMEGlobal*/
/*jshint browser: true*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Sun Dec 02 2018 07:53:57 GMT-0600 (Central Standard Time).
 */

define([
    'q',
    './joint.min',
    './joint.pn',
    'css!./joint.min.css',
    'css!./styles/JointJsWidget.css'], function (Q, joint, addPn) {
    'use strict';

    var JointJsWidget,
        WIDGET_CLASS = 'joint-js';

    JointJsWidget = function (logger, container) {
        this._logger = logger.fork('Widget');

        addPn(joint); //this extends the basic library with our own shapes

        console.log(joint);
        this._el = container;

        this.nodes = {};
        this._initialize();

        this._logger.debug('ctor finished');
    };

    JointJsWidget.prototype._initialize = function () {
        var width = this._el.width(),
            height = this._el.height(),
            self = this;

        // set widget class
        this._el.addClass(WIDGET_CLASS);
        this._jointPaper = document.createElement('div');
        this._el.append(this._jointPaper);
        $(this._jointPaper).attr('id', 'paper');

        this._graph = null;
        this._paper = null;
        this._pn = joint.shapes.pn;
        this._model = {places: {}, transitions: {}, links: {}, reverseLinks: {}};
        this._network = null;
    };

    JointJsWidget.prototype.clearNetwork = function () {
        if (this._graph) {
            this._graph.clear();
            this._model = {places: {}, transitions: {}, links: {}, reverseLinks: {}};
        }
    };

    JointJsWidget.prototype.initNetwork = function (network) {
        var self = this,
            trace = {},
            addPlace = function (name, position, tokens) {
                var place = new self._pn.Place({position: position, tokens: tokens}).attr('.label/text', name);

                place.addTo(self._graph);
                self._model.places[name] = place;
            },
            addTransition = function (name, position) {
                var transition = new self._pn.Transition({position: position}).attr('.label/text', name);

                transition.addTo(self._graph);
                self._model.transitions[name] = transition;
            },
            addConnection = function (from, to) {
                var fromElement = self._model.places[from] || self._model.transitions[from],
                    toElement = self._model.places[to] || self._model.transitions[to],
                    link = new self._pn.Link({
                        source: {id: fromElement.id, selector: '.root'},
                        target: {id: toElement.id, selector: '.root'}
                    });

                link.addTo(self._graph);
                self._model.links[from] = self._model.links[from] || {};
                self._model.links[from][to] = link;
                self._model.reverseLinks[to] = self._model.reverseLinks[to] || {};
                self._model.reverseLinks[to][from] = link;
            };

        self._network = network;

        if (self._graph === null && self._paper === null) {
            self._graph = new joint.dia.Graph();
            self._paper = new joint.dia.Paper({
                el: document.getElementById('paper'),
                width: this._el.width(),
                height: this._el.height(),
                gridSize: 10,
                defaultAnchor: {name: 'perpendicular'},
                defaultConnectionPoint: {name: 'boundary'},
                model: this._graph,
                interactive: false
            });
        }

        self.clearNetwork();
        Object.keys(network.places).forEach(function (placeName) {
            addPlace(placeName, network.places[placeName].position, network.places[placeName].tokens);
            trace[placeName] = network.places[placeName].tokens
        });

        Object.keys(network.transitions).forEach(function (transitionName) {
            addTransition(transitionName, network.transitions[transitionName].position);
        });

        network.connections.forEach(function (connection) {
            addConnection(connection.from, connection.to);
        });

        self._trace = [];
        self._trace.unshift(trace);

    };

    JointJsWidget.prototype._setNextState = function (trace) {
        var self = this;

        self._trace.unshift(trace);
        Object.keys(trace).forEach(function (placeName) {
            self._model.places[placeName].set('tokens', trace[placeName]);
        });
        console.log(self._trace.length);
    };

    JointJsWidget.prototype._getIncomingPlaceNames = function (transitionName) {
        return Object.keys(this._model.reverseLinks[transitionName]);
    };

    JointJsWidget.prototype._getOutgoingPlaceNames = function (transitionName) {
        return Object.keys(this._model.links[transitionName]);
    };

    JointJsWidget.prototype._getTransitionToFire = function () {
        //TODO just a placeholder now
    };

    JointJsWidget.prototype._fireTransition = function (transitionName) {
        var self = this,
            deferred = Q.defer(),
            transition = self._model.transitions[transitionName];

        self._graph.getConnectedLinks(transition, {inbound: true}).map(function (link) {
            link.findView(self._paper).sendToken(joint.V('circle', {r: 5, fill: '#feb662'}), 400);
        });

        setTimeout(function () {
            self._graph.getConnectedLinks(transition, {outbound: true}).map(function (link) {
                link.findView(self._paper).sendToken(joint.V('circle', {r: 5, fill: '#ed0051'}), 200);
            });
            setTimeout(function () {
                deferred.resolve();
            }, 200);
        }, 400);
        return deferred.promise;
    };

    JointJsWidget.prototype.stepForward = function () {
        var self = this,
            transitionToFire,
            nextState,
            currentState = JSON.parse(JSON.stringify(self._trace[0])); //needs to be copied for now

        //TODO needs a proper transition firing method
        Object.keys(currentState).forEach(function (placeName) {
            if (currentState[placeName].red > 1) {
                currentState[placeName].red -= 1;
            } else {
                currentState[placeName].red = 10;
            }

            if (currentState[placeName].blue > 1) {
                currentState[placeName].blue -= 1;
            } else {
                currentState[placeName].blue = 10;
            }

            if (currentState[placeName].yellow < 10) {
                currentState[placeName].yellow += 1;
            } else {
                currentState[placeName].yellow = 0;
            }
        });

        transitionToFire = self._getTransitionToFire();
        self._fireTransition(/*transitionToFire*/'go')
            .then(function (nextstate) {
                nextState = currentState; //this is part of the example and should be removed
                self._setNextState(nextState);
            });

    };

    JointJsWidget.prototype.stepBackward = function () {
        var self = this;

        if (self._trace.length > 1) {
            self._trace.shift();
            self._setNextState(self._trace.shift());
        }
    };

    JointJsWidget.prototype.resetTrace = function () {
        var self = this;

        self._trace = [self._trace.pop()];
        self._setNextState(self._trace[0]);
    };

    JointJsWidget.prototype.onWidgetContainerResize = function (width, height) {
        this._logger.debug('Widget is resizing...');

        if (this._paper) {
            this._paper.setDimensions(width, height);
        }
    };

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    JointJsWidget.prototype.destroy = function () {
    };

    JointJsWidget.prototype.onActivate = function () {
        this._logger.debug('JointJsWidget has been activated');
    };

    JointJsWidget.prototype.onDeactivate = function () {
        this._logger.debug('JointJsWidget has been deactivated');
    };

    return JointJsWidget;
});
